《基本概念》
一、引用：
类型名&引用名=某变量名
示例：
Int n=4;
Int &r=n;
注意：
(1)定义引用时一定要将其初始化成引用某个变量
(2)引用只能引用变量，不能引用常量和表达式。
(3)引用“从一而终”
(4)变量r的类型为int&.
r是n的引用名，相当于n的一个别名。类似于C语言中的typedef。
typedef int n; n是int的别名。
然而区别在于typedef是对变量类型的引用，而此处的&是对某个变量进行引用。
应用:
(1)	用于做交换数值函数的参数，可以直接达到交换数值的目的。
(2)	用于函数的返回值：
如int n=5;(全局变量)
int& Setvalue(){return n;}
int main(){
Setvalue()=40;
Cout<<n;
Return 0;
}
则最终输出n的值为40，实际上Setvalue()是对n的引用，从而对n进行赋值。
二、const关键字：
<1>常引用：
n=200;
Const int & r=n;
r=300;   X
n=300;  √
注意：
区分const T &与T & :一个是常引用，另一个是非常引用
(1)T&类型的引用或T类型的变量可以用来初始化const T &类型的引用
(2)反之不行，除非用强制类型转换（强制将变量转换成常量）
<2>常量指针：
例如：
int n;
const int *p=n;
*p=5;    X
n=4;    √
注意：
不能将常量指针的值赋给非常量指针
原因：const是个限定符，不能将你的限定强制加给别人。
三、动态内存分配
（1）new运算符：
格式：p=new T
T为任意类型名，P为类型为T*的指针，动态分配出一片大小为sizeof(T)字节的内存空间，并将该内存空间的起始地址赋给P。例如：
int *pn;
pn=new int;
*pn=5;
(2)delete运算符：
格式：<1>delete p;
      <2>delete []p;
例如：int *p=new int[20];
      int *q=new int;
      delete []p;
      delete q;
四、内联函数
1、概念：编译器处理内联函数时直接将整个函数的代码插入到调用语句处，从而不需要调用函数的语句，减少了函数调用的开销。
格式：在函数类型前加上inline
如：inline int Max(int a,int b)
{
	if(a>b) return a;
	return b;
}
五、函数重载
1.定义：一个或多个函数的名字相同，但参数个数或参数类型不同，叫做函数的重载。
2.举例：
int Max(double f1,double f2){};
int Max(int n1,int n2){};
int Max(int n1,int n2,int n3){};
六、函数的缺省参数
1.概念：C++中，定义函数的时候可以让最右边的连续若干个参数有缺省值，调用函数时若相应位置不写参数，参数就是缺省值。
如：void func(int x1,int x2=2,int x3=3){};
fuc(10);//等效于func(10,2,3)
func(10,8);//等效于func(10,8,3)
func(10,,8);//错误，只能让最右边的连续若干个参数缺省。	
2.意义：
（1）提高程序的可扩充性。
如果函数需要新增参数，而原先调用函数的语句未必需要新增参数，即可用缺省参数来避免对原先语句的修改。


《类与对象》
一、结构化程序设计与面向对象程序设计
1.结构化程序设计：
如：C语言
程序=数据结构+算法
程序由全局变量以及众多调用变量的函数组成
算法以函数的形式实现，用于对数据结构进行操作。
不足：
（1）函数与操作的数据结构没有直观联系
（2）随着程序规模的增加，程序逐渐难以理解。
如：
<1>某个数据结构到底有哪些函数可以对其操作？
<2>某个函数到底是用来操作哪些数据结构？
<3>任何两个函数之间有什么样的联系？
（3）没有封装和隐藏的概念，当变量定义有所改动时需要找出所有对变量操作的函数
（4）难以查错，当某个数据结构的值不对时难以找出到底是哪个函数导致的。
（5）难以移植代码
2.面向对象的程序设计：
（1）概念：将某类客观事物的共同特点归纳出来，形成一个数据结构。（可以用多个变量描述事物属性）
	   将这类事物的行为也归纳出来，形成一个个函数，通过这些函数操作数据结构。（抽象）
	   再通过某种语法形式将数据结构与操作数据结构的函数捆绑在一起，形成类，从而使得数据结构与操作该数据结构的算法呈现出显而易见的关系，称之为“封装”。
（2）类的实例称为对象。
（3）对象的内存分配：
对象所占用的内存空间的大小等于所有成员变量的大小之和。
（4）使用对象的成员：
<1>对象名.成员名
如：CRectangle r1,r2;
r1.w=5;
r2.Init（5，4）；
<2>指针->成员名
如：CRectangle r1,r2;
CRectangle *p1=&r1;
CRectangle *p2=&r2;
p1->w=5;
p2->Init(5,4);
<3>引用名.成员名
CRectangle r2;
CRectangle &rr=r2;
rr.w=5;
rr.Init(5,4);